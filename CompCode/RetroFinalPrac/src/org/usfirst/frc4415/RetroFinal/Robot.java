// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4415.RetroFinal;

import edu.wpi.first.wpilibj.CameraServer;
import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.TimedRobot;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.Scheduler;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SendableChooser;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc4415.RetroFinal.Robot;
import org.usfirst.frc4415.RetroFinal.commands.*;
import org.usfirst.frc4415.RetroFinal.subsystems.*;

import com.kauailabs.navx.frc.AHRS;

/**
 * The VM is configured to automatically run this class, and to call the
 * functions corresponding to each mode, as described in the TimedRobot
 * documentation. If you change the name of this class or the package after
 * creating this project, you must also update the build.properties file in 
 * the project.
 */
public class Robot extends TimedRobot {

    Command autonomousCommand;
    Command sideCommand;
    SendableChooser<Command> chooser = new SendableChooser<>();
    SendableChooser<Command> sideChooser = new SendableChooser<>();

    public static OI oi;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public static DriveTrainPID driveTrainPID;
    public static ClawPID clawPID;
    public static WedgeArmPID wedgeArmPID;
    public static Climber climber;
    public static TelescopePID telescopePID;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    
    private boolean telescopeReset = false;
    
    public static CameraServer server1;
    
    public static AHRS navX;

    /**
     * This function is run when the robot is first started up and should be
     * used for any initialization code.
     */
    @Override
    public void robotInit() {
        RobotMap.init();
        
        try {
        	navX = new AHRS(SPI.Port.kMXP);
        	navX.reset();
        } catch (RuntimeException ex ) {
        	DriverStation.reportError("Error instantiating navX MXP:  " + ex.getMessage(), true);
        	navX = null;
        }
        
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        driveTrainPID = new DriveTrainPID();
        clawPID = new ClawPID();
        wedgeArmPID = new WedgeArmPID();
        climber = new Climber();
        telescopePID = new TelescopePID();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
        
        server1 = CameraServer.getInstance();
        server1.startAutomaticCapture("cam1", 0);
        
        // OI must be constructed after subsystems. If the OI creates Commands
        //(which it very likely will), subsystems are not guaranteed to be
        // constructed yet. Thus, their requires() statements may grab null
        // pointers. Bad news. Don't move it.
        oi = new OI();

        // Add commands to Autonomous Sendable Chooser
        
        chooser.addDefault("Autonomous Command", new AutonomousCommand());
        chooser.addObject("Autonomous Command", new AutonomousCommand());
        chooser.addObject("Auto Command", new AutoCommand());
        chooser.addObject("Auto LeftSwitch Command", new AutoLeftSwitchCommand());
        chooser.addObject("Auto MiddleSwitch Command", new AutoMiddleSwitchCommand());
        chooser.addObject("Auto RightSwitch Command", new AutoRightSwitchCommand());
        chooser.addObject("Auto LeftScale Command", new AutoLeftScaleCommand());
        chooser.addObject("Auto MiddleScale Command", new AutoMiddleScaleCommand());
        chooser.addObject("Auto RightScale Command", new AutoRightScaleCommand());
  
        SmartDashboard.putData("Auto mode", chooser);
    }

    /**
     * This function is called when the disabled button is hit.
     * You can use it to reset subsystems before shutting down.
     */
    @Override
    public void disabledInit(){
    	
    	telescopeReset = false;
    	
    	clawPID.disable();
    	driveTrainPID.disable();
    	telescopePID.disable();
    	wedgeArmPID.disable();
    	wedgeArmPID.caseSetpoint = 0;
 
    }

    @Override
    public void disabledPeriodic() {
        Scheduler.getInstance().run();
    }

    @Override
    public void autonomousInit() {
        autonomousCommand = chooser.getSelected();
        // schedule the autonomous command (example)
        if (autonomousCommand != null) autonomousCommand.start();
        
        navX.reset();
        Robot.driveTrainPID.resetEncoder();
        Robot.wedgeArmPID.resetEncoder();
        
        SmartDashboard.putString("GameData: ", DriverStation.getInstance().getGameSpecificMessage());
        
    }

    /**
     * This function is called periodically during autonomous
     */
    @Override
    public void autonomousPeriodic() {
        Scheduler.getInstance().run();
       
        if (clawPID.getEncoder() > 35 && telescopeReset == false) {
        	if (Robot.telescopePID.getLimitSwitch1() == true) {
        		telescopePID.telescopeDownHalf();
        	}
        	telescopeReset = true;
        }
        
    }

    @Override
    public void teleopInit() {
        // This makes sure that the autonomous stops running when
        // teleop starts running. If you want the autonomous to
        // continue until interrupted by another command, remove
        // this line or comment it out.
        if (autonomousCommand != null) autonomousCommand.cancel();
        
        driveTrainPID.disable();
        driveTrainPID.resetEncoder();
        Robot.wedgeArmPID.resetEncoder();
        
    }

    /**
     * This function is called periodically during operator control
     */
    @Override
    public void teleopPeriodic() {
        Scheduler.getInstance().run();
        
        /*if (wristReset == false) {
        	clawPID.wristUp();
        	if (clawPID.getLimitSwitch() == false) {
        		wristReset = true;
        	}
        }*/
        
        SmartDashboard.putNumber("Telescope Encoder Ticks: ", Robot.telescopePID.getEncoder());
       
        if (clawPID.getEncoder() > 35 && telescopeReset == false) {
        	if (Robot.telescopePID.getLimitSwitch1() == true) {
        		telescopePID.telescopeDownHalf();
        	}
        	telescopeReset = true;
        }
        
        SmartDashboard.putNumber("Gyro Angle: ", navX.getAngle());
    }
}
